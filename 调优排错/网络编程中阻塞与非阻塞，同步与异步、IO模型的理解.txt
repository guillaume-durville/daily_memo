网络编程中阻塞与非阻塞，同步与异步、I/O模型的理解


1. 概念
同步Sync：
发出一个功能调用时，没有得到结果之前，该掉哟你就不返回
等待期间不能干别的事

异步Async：
当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者
如ajax请求时，请求通过事件触发->服务器触发->(客户端可以做其他事)->处理完毕

阻塞Block：
指调用结果返回之前，当前线程会被挂起(线程进入非可执行状态)，函数只有在得到结果之前才返回

非阻塞Unblock：
指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回


- 同步，就是调用一个功能，该功能没有结束前，死等结果
- 异步，就是调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）,（不必死等,会自动通知-回调）
- 阻塞，就是调用（函数），我（函数）没有接收完数据或者没有得到结果之前，（函数）不会返回
- 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者


同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！
阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！

同步：提交请求->等待服务器处理->处理完毕返回这个期间客户端浏览器不能干任何事
异步：请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

阻塞和非阻塞是指当进程访问的数据如果尚未就绪,进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪
同步和异步是指访问数据的机制,同步一般指主动请求并等待I/O操作完毕的方式,当数据就绪后在读写的时候必须阻塞(区别就绪与读写二个阶段,同步的读写必须阻塞),
异步则指主动请求数据后便可以继续处理其它任务,随后等待I/O,操作完毕的通知,这可以使进程在数据读写时也不阻塞。(等待"通知")



- Linux下的5种IO模型
阻塞IO: 进程会一直阻塞直到数据拷贝完成
非阻塞IO：非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；

IO复用select和pollI(/O multiplexing)：
主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听

信号驱动I/O(signal driven I/O; SIGIO)：两次调用，两次返回

异步I/O(asynchronous I/O)：数据拷贝的时候进程无需阻塞


epoll跟select都能提供多路I/O复用的解决方案
在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现


































